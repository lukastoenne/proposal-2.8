

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Fracture Simulation Workflow with Nodes &mdash; proposal-2.8 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="proposal-2.8 1.0 documentation" href="index.html"/>
        <link rel="next" title="Overview and ToDo list of topics" href="todo.html"/>
        <link rel="prev" title="Unified caching API" href="caching.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> proposal-2.8
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pipeline.html">Pipelines, Linking, Proxies, and Overrides</a></li>
<li class="toctree-l1"><a class="reference internal" href="object_nodes.html">Object Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">Unified caching API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Fracture Simulation Workflow with Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#particle-rigid-body-simulation">Particle Rigid Body Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-fracture">Dynamic Fracture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#apply-island-transforms">Apply Island Transforms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">Overview and ToDo list of topics</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">proposal-2.8</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Fracture Simulation Workflow with Nodes</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/fracture.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fracture-simulation-workflow-with-nodes">
<h1>Fracture Simulation Workflow with Nodes<a class="headerlink" href="#fracture-simulation-workflow-with-nodes" title="Permalink to this headline">¶</a></h1>
<p>There are two principal methods of fracturing:</p>
<ol class="arabic simple">
<li>User editing tools for manual fracturing</li>
<li>Dynamic fracturing of a mesh based on collisions</li>
</ol>
<p>Dynamic fracturing can also be seen as repeated application of the same tools as users would apply during editing, only based on collision events rather than operator invocations. So the description will focus on dynamic fracture and regard manual fracturing as a subset of this workflow.</p>
<p>Several distinct processes can be identified that have to work together for fracture effects:</p>
<ul>
<li><p class="first">Subdividing an existing mesh into smaller parts</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="first last figure" id="id1">
<a class="reference internal image-reference" href="_images/fracture_mesh1.png"><img alt="_images/fracture_mesh1.png" src="_images/fracture_mesh1.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-text">Fractured mesh</span></p>
</div>
</td>
<td><div class="first last figure" id="id2">
<a class="reference internal image-reference" href="_images/fracture_mesh4.png"><img alt="_images/fracture_mesh4.png" src="_images/fracture_mesh4.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-text">Internally all shards are centered</span></p>
</div>
</td>
</tr>
</tbody>
</table>
<p>There are a number of potential methods to be used here:</p>
<ul class="simple">
<li>regular polygonal grids</li>
<li>voronoi cells (given by their center points)</li>
<li>explicit fracture lines and planes</li>
</ul>
</li>
</ul>
<p>The description of the fractured mesh must be suitable to keep track of &#8220;shards&#8221;. Original mesh data stays untouched by the fracturing (non-destructive process), the shard meshes are stored separately.</p>
<p>Repeated application of the fracture process on the resulting shard meshes leads to a sequence of shard sets over time (increasing shard numbers with each fracture, but perhaps also removing too small shards for efficiency). This sequence constitutes an iterative process and the results should be cached.</p>
<ul>
<li><p class="first">Transform of individual shards</p>
<p>A transform can be kept for each shard without actually modifying vertex location. The &#8220;final&#8221; shard geometry for rendering can then be calculated from untransformed shard meshes. Particles are a suitable method of storing center points and rotations for each shard.</p>
</li>
<li><p class="first">Rigid Body simulation</p>
<div class="figure">
<img alt="_images/fracture_mesh2.png" src="_images/fracture_mesh2.png" />
</div>
<p>Particles represent rigid bodies with motion states (location, rotation and velocity). Shard meshes represent their collision shapes. The motion state of particles is used as the shard transform for rendering.</p>
</li>
<li><p class="first">Re-fracturing on collisions</p>
<div class="figure">
<img alt="_images/fracture_mesh3.png" src="_images/fracture_mesh3.png" />
</div>
<p>Collision events can be used to trigger another fracture on the current shard set. Collision contacts and impact forces are registered during the rigid body simulation step. After the rigid body step a post-process then re-fractures the shards (and modifies the particles to match).</p>
</li>
</ul>
<p>Fracture mesh data design internals have been discussed at length for the fracture modifier branch (T42306). For the purpose of this proposal it is assumed that a &#8220;fracture mesh&#8221; is simply a regular Mesh datablock that exists in the BlenderData. This datablock can be hooked up to an object as a mesh component, and then used as such in a node system.</p>
<p>The associated particle system is also a component of the same object. It is connected to the fracture mesh in three places:</p>
<div class="figure">
<img alt="_images/fracture_nodes_top.png" src="_images/fracture_nodes_top.png" />
</div>
<ol class="arabic simple">
<li>&#8220;Particle Rigid Body Simulation&#8221; node: Particles are used in the rigid body simulation as dynamic bodies. Their collision shapes are defined through the fracture mesh shards.</li>
<li>&#8220;Dynamic Fracture&#8221; node: Fracture is (optionally) applied to shards and particles as a post-process after simulation, using cached collision contacts.</li>
<li>&#8220;Apply Island Transforms&#8221; node: For rendering a final mesh (DerivedMesh) is generated from the fracture mesh by applying the particle transforms on each shard. The result is a single regular mesh with the transforms &#8220;baked in&#8221;, so that it works just like any other mesh for the renderer.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The data flow of particles and mesh data. The “Components” node provides access to particle and mesh data created by the user. When passed to the “Rigid Body” node and then to the “Dynamic Fracture” node this data is modified in each node, first by adding motion state particle attributes and then by applying the fracture algorithm. Read-only sockets are shown transparent, they can form branches of the main data flow.</p>
</div>
<p>Each of the nodes could in turn be broken down into a subgraph, so let’s have a look at their internals.</p>
<div class="section" id="particle-rigid-body-simulation">
<h2>Particle Rigid Body Simulation<a class="headerlink" href="#particle-rigid-body-simulation" title="Permalink to this headline">¶</a></h2>
<p>Rigid Body simulation requires interaction of many objects on the same level. Other simulations can be hierarchical. e.g. hair bounces off an obstacle but the obstacle is not affected by the much lighter hair. Rigid bodies have to collide with each other, so the solver works on a scene-wide level.</p>
<p>The consequence is that a rigid body node is not a closed function, but has to communicate with the RB solver through the dependency graph. The process is split into a &#8220;pre RB sim&#8221; part, and a &#8220;post RB sim&#8221; part which has to wait for the completion of the rigid body time step.</p>
<div class="figure">
<img alt="_images/fracture_nodes_rigidbody1.png" src="_images/fracture_nodes_rigidbody1.png" />
</div>
<p>A list of rigid bodies is created for each particle. The RB simulation world keeps track of existing RBs, which are identified through their &#8220;id&#8221; value (matching ids of particles), so that we can map back motion states to particles.
Many more physical properties of RBs could be defined here, depending on the desired features of the fractured mesh. For instance, restitution factors (&#8220;bouncyness&#8221;) are quite important for the &#8220;feel&#8221; of a simulation. For the sake of simplicity we will ignore these aspects now and assume the RB sim uses sensible defaults.</p>
<div class="figure">
<img alt="_images/fracture_nodes_rigidbody2.png" src="_images/fracture_nodes_rigidbody2.png" />
</div>
<p>Apply the resulting motion state from RB sim on the particles.
Importantly this node has a dependency on the RB step inside the depsgraph! That means that the object update can not be scheduled as a single monolithic depsgraph event, but must be broken into at least 2 pieces, PRE_RIGIDBODY and POST_RIGIDBODY, which get scheduled accordingly.</p>
</div>
<div class="section" id="dynamic-fracture">
<h2>Dynamic Fracture<a class="headerlink" href="#dynamic-fracture" title="Permalink to this headline">¶</a></h2>
<div class="figure">
<img alt="_images/fracture_nodes_fracture1.png" src="_images/fracture_nodes_fracture1.png" />
</div>
<p>Store a list of contact points for each RB/particle/shard during the RB time step, along with impact forces from collision. This node will have to inform the rigid body system (Bullet) to cache contacts before the time step is calculated. After the time step this contact info can then be accessed as a yet-to-be-defined data structure.</p>
<div class="figure">
<img alt="_images/fracture_nodes_fracture2.png" src="_images/fracture_nodes_fracture2.png" />
</div>
<p>This is a very simple approach to dynamic fracturing: Find the single largest impact for each shard, then fracture the shard based on that impact vector. The exact method is left unspecified here. Much more elaborate methods could be imagined here of course, right up to using a full FEM system. However, for the purposes of CG a simple algorithm is probably preferable for performance and controllability.</p>
<p>The result in any case will be two new lists of shards and associated particles. Usually (but not necessarily) these will be larger than the original lists, when shards get split into multiple pieces.</p>
</div>
<div class="section" id="apply-island-transforms">
<h2>Apply Island Transforms<a class="headerlink" href="#apply-island-transforms" title="Permalink to this headline">¶</a></h2>
<p>The display mesh starts out as a plain copy of the fracture mesh (with all shards centered on the origin).</p>
<div class="figure">
<img alt="_images/fracture_nodes_applytransform1.png" src="_images/fracture_nodes_applytransform1.png" />
</div>
<p>We then want to transform the vertex locations using the particle motion state transforms. However, there are fewer particles than vertices, so we first have to map particle transforms onto a per-vertex transform list!</p>
<div class="figure">
<img alt="_images/fracture_nodes_applytransform2.png" src="_images/fracture_nodes_applytransform2.png" />
</div>
<p>This is done by getting the shard index from vertices (matching the particle index), and then mapping the particle transforms. The result is a new list that repeats each particle transform for the range of vertices of that shard.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>shard: (1,1,1, 2,2,2,2, 3,3,3, 4,4,4,4,4)
pa_tfm: (T1, T2, T3, T4)
=&gt; map(pa_tfm, shard) = (T1,T1,T1, T2,T2,T2,T2, T3,T3,T3, T4,T4,T4,T4,T4)
</pre></div>
</div>
<div class="figure">
<img alt="_images/fracture_nodes_applytransform3.png" src="_images/fracture_nodes_applytransform3.png" />
</div>
<p>Finally the per-vertex transforms can be applied to create a modified vertex location list. By setting this as the new vertex location attribute we complete the mesh result.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="todo.html" class="btn btn-neutral float-right" title="Overview and ToDo list of topics" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="caching.html" class="btn btn-neutral" title="Unified caching API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Lukas Tönne.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>